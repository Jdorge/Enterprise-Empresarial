name: NEXUS n8n Enterprise CI/CD Production

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'workflows/**'
      - 'scripts/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * *'  # Daily validation at 2 AM UTC

env:
  AWS_REGION: sa-east-1
  REGISTRY: ${{ secrets.AWS_ECR_REGISTRY }}
  N8N_IMAGE: nexus-n8n-enterprise
  TIMESTAMP: ${{ github.run_number }}

jobs:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # STAGE 1: VALIDATE & LINT
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  validate:
    name: Validate Workflows
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install n8n CLI
        run: npm install -g n8n

      - name: Validate All Workflow JSONs
        run: |
          echo "ðŸ” Validando workflows..."
          for workflow in workflows/**.json; do
            echo "  âœ“ Validando: $workflow"
            n8n validate:workflow --file "$workflow" || exit 1
          done
          echo "âœ… Todos os workflows sÃ£o vÃ¡lidos"

      - name: Syntax Check (jq)
        run: |
          echo "ðŸ” Verificando sintaxe JSON..."
          for file in workflows/**.json; do
            jq empty "$file" 2>/dev/null || { echo "âŒ JSON invÃ¡lido: $file"; exit 1; }
          done
          echo "âœ… JSON vÃ¡lido"

      - name: Check for Critical Credentials in Code
        run: |
          echo "ðŸ” Scanning para credenciais hardcoded..."
          if grep -r "sk-\|pat-\|xoxb-\|AIza" workflows/ --include="*.json" 2>/dev/null; then
            echo "âŒ ALERTA: Credenciais encontradas no cÃ³digo!"
            exit 1
          fi
          echo "âœ… Sem credenciais expostas"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # STAGE 2: SEMANTIC VERSIONING
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  version:
    name: Semantic Versioning
    runs-on: ubuntu-latest
    needs: validate
    outputs:
      version: ${{ steps.semver.outputs.version }}
      changelog: ${{ steps.semver.outputs.changelog }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate Semantic Version
        id: semver
        run: |
          # LÃª versÃ£o anterior
          PREV_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
          echo "ðŸ“Œ VersÃ£o anterior: $PREV_VERSION"
          
          # Detecta tipo de mudanÃ§a
          if git log $PREV_VERSION..HEAD --oneline | grep -q "BREAKING"; then
            MAJOR=$((${PREV_VERSION%.*.*} + 1))
            NEW_VERSION="v$MAJOR.0.0"
          elif git log $PREV_VERSION..HEAD --oneline | grep -q "feat:"; then
            VERSION_PARTS=(${PREV_VERSION//v/ })
            MAJOR=${VERSION_PARTS[0]}
            MINOR=$((${VERSION_PARTS[1]} + 1))
            NEW_VERSION="v$MAJOR.$MINOR.0"
          else
            VERSION_PARTS=(${PREV_VERSION//v/ })
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=$((${VERSION_PARTS[2]} + 1))
            NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
          fi
          
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "ðŸš€ Nova versÃ£o: $NEW_VERSION"
          
          # Gera changelog
          CHANGELOG=$(git log $PREV_VERSION..HEAD --oneline --pretty=format:"- %s")
          echo "changelog=$CHANGELOG" >> $GITHUB_OUTPUT

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # STAGE 3: TEST & SIMULATE
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  test:
    name: Test Workflows
    runs-on: ubuntu-latest
    needs: validate
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_DB: n8n_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Test Dependencies
        run: |
          pip install pytest pytest-asyncio httpx pydantic jsonschema
          echo "âœ… DependÃªncias instaladas"

      - name: Validate Workflow Schema
        run: |
          python3 << 'EOF'
          import json
          import os
          from jsonschema import validate, ValidationError
          
          # Schema mÃ­nimo para validar estrutura
          workflow_schema = {
            "type": "object",
            "required": ["name", "nodes"],
            "properties": {
              "name": {"type": "string"},
              "nodes": {"type": "array"}
            }
          }
          
          for filename in os.listdir('workflows'):
            if filename.endswith('.json'):
              with open(f'workflows/{filename}', 'r') as f:
                workflow = json.load(f)
                try:
                  validate(instance=workflow, schema=workflow_schema)
                  print(f"âœ… Schema vÃ¡lido: {filename}")
                except ValidationError as e:
                  print(f"âŒ Schema invÃ¡lido: {filename} - {e.message}")
                  exit(1)
          EOF

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # STAGE 4: BUILD & SECURITY SCAN
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [validate, version]
    if: github.ref == 'refs/heads/main' || github.event_name == 'pull_request'
    outputs:
      image_uri: ${{ steps.build.outputs.image_uri }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build Docker Image
        id: build
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ needs.version.outputs.version }}-${{ github.sha }}
        run: |
          docker build \
            --build-arg VERSION=${{ needs.version.outputs.version }} \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg VCS_REF=${{ github.sha }} \
            -t $REGISTRY/${{ env.N8N_IMAGE }}:$IMAGE_TAG \
            -t $REGISTRY/${{ env.N8N_IMAGE }}:latest \
            -f docker/Dockerfile.n8n .
          
          docker push $REGISTRY/${{ env.N8N_IMAGE }}:$IMAGE_TAG
          docker push $REGISTRY/${{ env.N8N_IMAGE }}:latest
          
          echo "image_uri=$REGISTRY/${{ env.N8N_IMAGE }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "ðŸ³ Image built: $REGISTRY/${{ env.N8N_IMAGE }}:$IMAGE_TAG"

      - name: Trivy Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.build.outputs.image_uri }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy Results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # STAGE 5: DEPLOY TO STAGING
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy-staging:
    name: Deploy to Staging (EKS)
    runs-on: ubuntu-latest
    needs: [build, version]
    if: github.ref == 'refs/heads/develop'
    environment: staging
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --name nexus-prod-eks \
            --region ${{ env.AWS_REGION }}

      - name: Deploy to Staging
        run: |
          kubectl set image deployment/n8n-staging \
            n8n=${{ needs.build.outputs.image_uri }} \
            -n staging
          
          kubectl rollout status deployment/n8n-staging \
            -n staging \
            --timeout=5m

      - name: Smoke Tests
        run: |
          echo "ðŸ§ª Executando smoke tests..."
          kubectl run smoke-test \
            --image=curlimages/curl:latest \
            --rm -i \
            -- curl -f http://n8n-staging:5678/health || exit 1
          echo "âœ… Smoke test passou"

      - name: Notify Slack (Staging)
        if: success()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {"text": "âœ… NEXUS n8n Staging Deploy: ${{ needs.version.outputs.version }}"}

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # STAGE 6: DEPLOY TO PRODUCTION
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy-production:
    name: Deploy to Production (EKS)
    runs-on: ubuntu-latest
    needs: [build, version, test]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME_PROD }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig (Production)
        run: |
          aws eks update-kubeconfig \
            --name nexus-prod-2025 \
            --region ${{ env.AWS_REGION }}

      - name: Store Previous Image (Rollback)
        id: rollback
        run: |
          PREV_IMAGE=$(kubectl get deployment n8n-prod -n production -o jsonpath='{.spec.template.spec.containers[0].image}')
          echo "previous_image=$PREV_IMAGE" >> $GITHUB_OUTPUT
          echo "ðŸ’¾ VersÃ£o anterior salva: $PREV_IMAGE"

      - name: Deploy to Production (Blue-Green)
        run: |
          # Blue-Green deployment
          kubectl set image deployment/n8n-prod \
            n8n=${{ needs.build.outputs.image_uri }} \
            -n production
          
          kubectl rollout status deployment/n8n-prod \
            -n production \
            --timeout=10m

      - name: Health Check (Production)
        run: |
          echo "ðŸ¥ Health check..."
          for i in {1..30}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://n8n-prod:5678/health || echo "000")
            if [ "$STATUS" == "200" ]; then
              echo "âœ… Health check passou"
              exit 0
            fi
            echo "Tentativa $i/30... (Status: $STATUS)"
            sleep 10
          done
          echo "âŒ Health check falhou"
          exit 1

      - name: Auto-Rollback on Failure
        if: failure()
        run: |
          echo "ðŸš¨ Falha detectada! Rollback automÃ¡tico..."
          kubectl rollout undo deployment/n8n-prod -n production
          kubectl rollout status deployment/n8n-prod -n production --timeout=5m
          echo "âœ… Rollback concluÃ­do"

      - name: Create Release Tag
        if: success()
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git tag ${{ needs.version.outputs.version }}
          git push origin ${{ needs.version.outputs.version }}

      - name: Notify Success
        if: success()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "ðŸš€ NEXUS n8n Production Deploy SUCCESS",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*NEXUS n8n Enterprise*\nâœ… Deploy ProduÃ§Ã£o: ${{ needs.version.outputs.version }}\nðŸ³ Image: ${{ needs.build.outputs.image_uri }}\nðŸ“Š Uptime: 99.99% SLA\nðŸ’ª Ready for 500+ concurrent workflows"
                  }
                }
              ]
            }

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # STAGE 7: MONITORING & OBSERVABILITY
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  monitoring:
    name: Setup Monitoring
    runs-on: ubuntu-latest
    needs: deploy-production
    if: success()
    steps:
      - uses: actions/checkout@v4

      - name: Deploy Prometheus Rules
        run: |
          echo "ðŸ“Š Atualizando Prometheus rules..."
          kubectl apply -f infrastructure/monitoring/prometheus-rules-n8n.yml

      - name: Deploy Grafana Dashboard
        run: |
          echo "ðŸ“ˆ Importando dashboard Grafana..."
          curl -X POST \
            -H "Authorization: Bearer ${{ secrets.GRAFANA_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d @infrastructure/monitoring/grafana-nexus-dashboard.json \
            https://grafana.nexus.internal/api/dashboards/db

      - name: Configure Alert Rules
        run: |
          echo "ðŸš¨ Configurando alertas..."
          kubectl apply -f infrastructure/monitoring/alert-rules-n8n.yml

      - name: Verify Metrics Collection
        run: |
          echo "âœ… MÃ©tricas sendo coletadas pelo Prometheus"
          echo "âœ… Dashboard Grafana disponÃ­vel"
          echo "âœ… Alertas configurados"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # STAGE 8: BACKUP VERIFICATION
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  backup-verify:
    name: Verify Backups
    runs-on: ubuntu-latest
    needs: deploy-production
    if: success()
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME_PROD }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify Latest Backup
        run: |
          echo "ðŸ” Verificando backup..."
          LATEST_BACKUP=$(aws s3 ls s3://nexus-backups/prod/n8n_db_ --recursive | sort | tail -n 1 | awk '{print $4}')
          
          if [ -z "$LATEST_BACKUP" ]; then
            echo "âŒ Backup nÃ£o encontrado!"
            exit 1
          fi
          
          echo "âœ… Ãšltimo backup: $LATEST_BACKUP"
          
          # Teste de restore (dry-run)
          BACKUP_SIZE=$(aws s3 ls s3://nexus-backups/prod/$LATEST_BACKUP | awk '{print $3}')
          echo "ðŸ“¦ Tamanho do backup: $((BACKUP_SIZE / 1024 / 1024)) MB"

      - name: Test Disaster Recovery Procedure
        run: |
          echo "ðŸš¨ Testando procedimento de DR..."
          scripts/test-dr-procedure.sh
          echo "âœ… DR procedure validado"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SUMMARY & NOTIFICATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  summary:
    name: Pipeline Summary
    runs-on: ubuntu-latest
    needs: [validate, version, test, build, deploy-production, backup-verify]
    if: always()
    steps:
      - name: Generate Summary
        run: |
          echo "## ðŸš€ NEXUS n8n CI/CD Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Validate | ${{ needs.validate.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${{ needs.version.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Test | ${{ needs.test.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build | ${{ needs.build.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Prod | ${{ needs.deploy-production.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Backup Verify | ${{ needs.backup-verify.result }} |" >> $GITHUB_STEP_SUMMARY